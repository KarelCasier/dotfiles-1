#!/usr/bin/env bash
# vim:set ft=sh:foldmethod=marker:
# ██████╗  █████╗ ███████╗██╗  ██╗██████╗  ██████╗
# ██╔══██╗██╔══██╗██╔════╝██║  ██║██╔══██╗██╔════╝
# ██████╔╝███████║███████╗███████║██████╔╝██║
# ██╔══██╗██╔══██║╚════██║██╔══██║██╔══██╗██║
# ██████╔╝██║  ██║███████║██║  ██║██║  ██║╚██████╗
# ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝

# General {{{
  # If not running interactively, don't continue
  [ -z "$PS1" ] && return

  if [ -f /etc/bashrc ]; then
    . /etc/bashrc   # --> Read /etc/bashrc, if present.
  fi

  # Case-insensitive globbing (used in pathname expansion)
  shopt -s nocaseglob;

  # Autocorrect typos in path names when using `cd`
  shopt -s cdspell;

  # Enable some Bash 4 features when possible:
  # * `autocd`, e.g. `**/qux` will enter `./foo/bar/baz/qux`
  # * Recursive globbing, e.g. `echo **/*.txt`
  for option in autocd globstar; do
    shopt -s "$option" 2> /dev/null;
  done;

  # Better history
  shopt -s histappend
  shopt -s cmdhist
  export HISTFILESIZE=1000000
  export HISTSIZE=1000000
  export HISTCONTROL=ignoreboth:erasedups
  export HISTIGNORE='ls:bg:fg:history'
  export HISTTIMEFORMAT='%F %T '
  [[ "$PROMPT_COMMAND" != "*history*" ]] && export PROMPT_COMMAND="history -a;$PROMPT_COMMAND"

# }}}

# User interface {{{

  # Set custom prompt with git info included when available
  source ~/.git-prompt.sh
  _PS1 ()
  {
    local PRE= NAME="$1" LENGTH="$2";
    [[ "$NAME" != "${NAME#$HOME/}" || -z "${NAME#$HOME}" ]] &&
        PRE+='~' NAME="${NAME#$HOME}" LENGTH=$[LENGTH-1];
    ((${#NAME}>$LENGTH)) && NAME="/...${NAME:$[${#NAME}-LENGTH+4]}";
    echo "$PRE$NAME"
  }

  # If we are not connected through SSH or TTY, use custom PS1
  if [ -z "$SSH_CLIENT" ] && [ -z "$SSH_TTY" ]; then
    export PS1='$(_PS1 "$PWD" 20)$(__git_ps1) \[\e[31;1m\]❯\[\e[0m\]\[\e[33;1m\]❯\[\e[0m\]\[\e[32;1m\]❯\[\e[0m\] '
  fi

  # Load bash_completion (it is important to load it before fzf)
  if command -v brew >/dev/null 2>&1; then
    if [ -f $(brew --prefix)/etc/bash_completion ]; then
      source $(brew --prefix)/etc/bash_completion
    fi
  else
    if [ -f /usr/share/bash-completion/bash_completion ]; then
      . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
      . /etc/bash_completion
    fi
  fi

  # Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
  [ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2- | tr ' ' '\n')" scp sftp ssh;

# }}}

# Aliases and functions {{{

  # Pretty-print of PATH variables
  alias path='echo -e ${PATH//:/\\n}'

  # Some sane aliases
  alias mkdir='mkdir -p'
  alias ..='cd ..'

  # Detect which `ls` flavor is in use
  if ls --color > /dev/null 2>&1; then # GNU `ls`
    colorflag="--color"
  else # OS X `ls`
    colorflag="-G"
  fi

  # Add colors for filetype and  human-readable sizes by default on 'ls':
  alias ls="ls -h ${colorflag}"
  alias lk='ls -lSr'         #  Sort by size, biggest last.
  alias lt='ls -ltr'         #  Sort by date, most recent last.
  alias lc='ls -ltcr'        #  Sort by/show change time,most recent last.
  alias lu='ls -ltur'        #  Sort by/show access time,most recent last.

  # The ubiquitous 'll'
  alias ll="ls -lG"
  alias lm='ll | more'       #  Pipe through 'more'
  alias lr='ll -R'           #  Recursive ls.
  alias la='ll -A'           #  Show hidden files.
  alias tree='tree -Csuh'    #  Nice alternative to 'recursive ls' ...

  # Update and cleanup brew
  if command -v brew >/dev/null 2>&1; then
    export PYTHONPATH=$(brew --prefix)/lib/python2.7/site-packages:$PYTHONPATH
    alias brewup='brew update && brew upgrade --all && brew cleanup && brew cask cleanup'
  fi

  # Copy-paste (requires xclip on *NIX systems)
  if command -v xclip >/dev/null 2>&1; then
    alias pbcopy='xclip -i -selection clipboard'
    alias pbpaste='xclip -o -selection clipboard'
  fi

  # Enhanced WHOIS lookups
  alias whois="whois -h whois-servers.net"

  # Run with in server mode to allow eclim debugger, open eclim project and start session recording
  function vjava () {
    $EDITOR --servername "$1" +Session +"ProjectOpen $1"
  }

  # Serve current directory as HTTP server, optionally specifying the port (default is 8000)
  function serve() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
  }

  # Handy Extract Program
  function extract() {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.bz2)   tar xvjf $1     ;;
        *.tar.gz)    tar xvzf $1     ;;
        *.bz2)       bunzip2 $1      ;;
        *.rar)       unrar x $1      ;;
        *.gz)        gunzip $1       ;;
        *.tar)       tar xvf $1      ;;
        *.tbz2)      tar xvjf $1     ;;
        *.tgz)       tar xvzf $1     ;;
        *.zip)       unzip $1        ;;
        *.Z)         uncompress $1   ;;
        *.7z)        7z x $1         ;;
        *)           echo "'$1' cannot be extracted via >extract<" ;;
      esac
    else
      echo "'$1' is not a valid file!"
    fi
  }

  # Creates an archive (*.tar.gz) from given directory.
  function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

  # Create a ZIP archive of a file or folder.
  function makezip() { zip -r "${1%%/}.zip" "$1" ; }

  # Make your directories and files access rights sane.
  function sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}

# }}}

# Colors {{{

  # Enable colors
  export CLICOLOR=1

  # Enable 256 color mode
  # [[ $TMUX = "" ]] && export TERM="xterm-256color"

  # Base 16
  BASE16_SHELL=$DOTHOME/lib/bash/base16-shell/
  [ -s $BASE16_SHELL/profile_helper.sh ] && eval "$($BASE16_SHELL/profile_helper.sh)"
  [ -z $BASE16_THEME ] && base16_tomorrow-night

# }}}

# Plugins {{{

  # Init fasd with cache to speed up startup
  source "$DOTHOME/lib/bash/fasd/fasd" > /dev/null
  fasd_cache=~/.fasd-init-cache
  if [ "$(command -v fasd)" -nt "$fasd_cache" -o ! -s "$fasd_cache" ]; then
    fasd --init posix-alias bash-hook bash-ccomp bash-ccomp-install >| "$fasd_cache"
  fi
  source "$fasd_cache"
  unset fasd_cache

  # Add viminfo fasd command
  alias v='f -e vim -b viminfo'
  _fasd_bash_hook_cmd_complete v

  # Load fzf
  source ~/.fzf.bash

  # Use faster grep command if possible
  if command -v rg >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden --follow'
  elif command -v ag >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='ag -g ""'
  fi

  # Load rest of libraries
  # command -v thefuck >/dev/null 2>&1 && eval "$(thefuck --alias)"
  command -v hub >/dev/null 2>&1 && eval "$(hub alias -s)"

# }}}

# User configuration {{{

  # Simple helper to manage dotfiles setup
  dottool() {
    case ${1} in
      # Update dotfiles
      -u|--update)
        git -C "$DOTHOME" pull --rebase
        eval "$DOTHOME/install"
        ;;
      # Fast open and edit user rc files
      -o|--open)
        eval "$EDITOR $DOTHOME/usr/$2"
        ;;
      # Add link to $DOTHOME/usr/bin what is added to $PATH
      -l|--link)
        local name=`basename $2`
        local curpath="$PWD/$2"
        ln -s $curpath "$DOTHOME/usr/bin/$name"
        ;;
      # Add Vim plugin as submodule
      -v|--vim-plugin)
        (cd "$DOTHOME/usr/vim"; git clone "$2")
        ;;
      -h|--help)
        echo -e "usage: "
        echo -e "\t-u | --update                      update adrc"
        echo -e "\t-o | --open <configuration_file>   fast open and edit confiuration files (bashrc, vimrc, tmux.conf, gitconfig)"
        echo -e "\t-l | --link <file>                 add link to $DOTHOME/usr/bin what is in \$PATH variable (useful for adding CLI things)"
        echo -e "\t-v | --vim-plugin <git_repository> add vim plugin as git submodule to $DOTHOME/usr/vim"
        echo -e "\t-h | --help                        show this message"
        ;;
      *)
        echo "Wrong command '${1}'. See --help"
        ;;
    esac
  }

  # Load user config
  [[ -f "$DOTHOME/usr/bashrc" ]] &&
    source "$DOTHOME/usr/bashrc"

# }}}
